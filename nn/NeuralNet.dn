component provides nn.NeuralNet requires gpu.LogicalComputeDevice, io.Output out, data.DecUtil du, data.IntUtil iu, data.adt.List, time.Timer t{

    LogicalComputeDevice myDevice

    int inputSize
    int trainingSetSize
    int outputSize
    int hiddenLayerSizes[]

    int activationMethod
    int trainingAlgo

    NeuralNet:NeuralNet() {
        myDevice = new LogicalComputeDevice()
        //load required programs
        myDevice.loadProgram("/home/ben/Documents/PhD/DanaOpenCL/resources-ext/opencl_kernels/randmat.cl", "randMat")
        int dims[] = new int[2]
        dims[0] = 10
        dims[1] = 20
        myDevice.createMatrix("A", FLOAT, 2, dims)
        String params[] = new String[2]
        params[0] = new String("const:10")
        params[1] = new String("A")
        myDevice.runProgram("randMat", params)
        t.sleep(10000) 
        Matrix result = myDevice.readMatrix("A")
        dec res[][] = result.fvalues
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 20; j++) {
                out.print("$(du.makeString(res[i][j]))|")
            }
            out.print("\n")
        }
    }
    void NeuralNet:setInputVectorSize(int sz){
        inputSize = sz
    }
    void NeuralNet:setTrainingSetSize(int sz){
        trainingSetSize = sz
    }
    void NeuralNet:setOutputVectorSize(int sz){
        outputSize = sz
    }
    void NeuralNet:setHiddenLayerSizes(int sz[]){
        hiddenLayerSizes = sz
    }
    void NeuralNet:setHiddenLayerActivation(int layer, int function){
        activationMethod = function
    }
    void NeuralNet:setTrainingAlgo(int algo){
        trainingAlgo = algo
    }
    void NeuralNet:train(dec trainSet[][]){
        myDevice.createMatrix("trainingMatrix", 1, 2, new int[2](inputSize, trainingSetSize))
        myDevice.writeMatrix("trainingMatrix", trainSet, null)

        for (int i = 0; i < hiddenLayerSizes.arrayLength; i++) {
            if (i = 0) {
                myDevice.createMatrix("w$(i)", 1, 2, new int[2](hiddenLayerSizes[i], inputSize))
                myDevice.createArray("b$(i)", 1, inputSize)
            }
            else {
                myDevice.createMatrix("w$(i)", 1, 2, new int[2](hiddenLayerSizes[i], hiddenLayerSizes[i-1]))
                myDevice.createArray("b$(i)", 1, hiddenLayerSizes[i-1])
            }
        }

        myDevice.createArray("output", 1, outputSize)

        
    }

    dec[] NeuralNet:predict(dec vect[]){
        return null

    }
    
}
