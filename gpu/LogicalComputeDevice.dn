component provides LogicalComputeDevice requires gpu.Compute,
                                                gpu.ComputeDistributionManager,
                                                gpu.ComputeManager,
                                                data.adt.List,
                                                data.adt.HashTable,
                                                data.adt.Queue,
                                                io.Output out,
                                                io.TextFile,
                                                data.IntUtil iu,
                                                data.StringUtil su,
                                                data.DecUtil du
                                                {

    ComputeDistributionManager distManager
    Compute nat

    HashTable readQueues
    HashTable writeQueues

    HashTable openMemoryAreas
    
    HashTable programs

    LogicalComputeDevice:LogicalComputeDevice() {
        nat = new Compute()
        ComputeManager cm = new ComputeManager(nat)
        distManager = new ComputeDistributionManager(cm, nat)

        readQueues = new HashTable()
        writeQueues = new HashTable()

        openMemoryAreas = new HashTable()

        programs = new HashTable()

        HashTableItem rw[] = rclone distManager.getReadWriteQueues(new HashTable[2])
        for (int i = 0; i < rw.arrayLength; i++) {
            HashTableItem nextItem = rw[i]
            ChandleWrapper x = nextItem.value

            int queue_cl = nat.createSynchQueue_w(x.handle)
            ComputeQueue readQueue = new ComputeQueue(queue_cl, new Queue(), new String(nextItem.key))
            readQueues.put(nextItem.key, readQueue)
            
            queue_cl = nat.createSynchQueue_w(x.handle)
            readQueue = new ComputeQueue(queue_cl, new Queue(), new String(nextItem.key))
            writeQueues.put(nextItem.key, readQueue)
        }
    }


    void LogicalComputeDevice:createArray(char name[], int types, int length) {
        HashTableItem device = distManager.mallocWhichDevice()
        ChandleWrapper deviceHandle = device.value
        char deviceName[] = device.key
        int clMemObj = nat.createArray_w(deviceHandle.handle, length, types)
        ChandleWrapper arrayHandle = new ChandleWrapper(clMemObj)
        int lengths[] = new int[1]
        lengths[0] = length
        OpenMemArea newMem = new OpenMemArea(arrayHandle, new String(deviceName), 1, lengths, types)
        openMemoryAreas.put(name, newMem)
        return 
    }

    void LogicalComputeDevice:createMatrix(char name[], int type, int dim, int lengths[]) {
        HashTableItem device = distManager.mallocWhichDevice()
        ChandleWrapper deviceHandle = device.value
        char deviceName[] = device.key
        int clMemObj = nat.createMatrix_w(deviceHandle.handle, lengths[0], lengths[1], type)
        out.println("lens: $(lengths[0]), $(lengths[1])")
        ChandleWrapper matrixHandle = new ChandleWrapper(clMemObj)
        OpenMemArea newMem = new OpenMemArea(matrixHandle, new String(deviceName), dim, lengths, type)
        openMemoryAreas.put(name, newMem)
        return 
    }

    void LogicalComputeDevice:writeArray(char name[], dec fvalues[], int ivalues[]) {
        //get memObj from HashTable
        OpenMemArea inMem = openMemoryAreas.get(name)
        ChandleWrapper hand = inMem.hand
        int clMemObj = hand.handle

        String device = inMem.device

        //check values.len = memObj.len
        ComputeQueue q = writeQueues.get(device.string)
        int clQueue = q.queue_cl

        if (inMem.type == FLOAT && ivalues == null && fvalues.arrayLength == inMem.lengths[0]) {
            nat.writeFloatArray_w(clQueue, clMemObj, fvalues)
        }
        else if (inMem.type == UINT && fvalues == null && ivalues.arrayLength == inMem.lengths[0]) {
            nat.writeIntArray_w(clQueue, clMemObj, ivalues) 
        }
        else {
            out.println("err in LCD write array")
        }
    }

    Vector LogicalComputeDevice:readArray(char name[]) {
        Vector v = new Vector()
        OpenMemArea inMem = openMemoryAreas.get(name)
        ChandleWrapper hand = inMem.hand
        int clMemObj = hand.handle

        String device = inMem.device

        ComputeQueue q = readQueues.get(device.string)
        int clQueue = q.queue_cl

        if (inMem.type == FLOAT) {
            dec buf[] = new dec[inMem.lengths[0]]

            buf = nat.readFloatArray_w(clQueue, clMemObj, inMem.lengths[0])
            v.fvalues = buf
            v.ivalues = null
            return v
        }
        else {
            int buf[] = new int[inMem.lengths[0]]

            buf = nat.readIntArray_w(clQueue, clMemObj, buf)
            v.ivalues = buf
            v.fvalues = null
            return v
        }
    }

    void LogicalComputeDevice:writeMatrix(char name[], dec fvalues[][], int ivalues[][]) {
        OpenMemArea inMem = openMemoryAreas.get(name)
        ChandleWrapper hand = inMem.hand
        int memObj = hand.handle

        String device = inMem.device

        ComputeQueue q = writeQueues.get(device.string)
        int clQueue = q.queue_cl

        if (inMem.type == FLOAT && ivalues == null && fvalues.arrayLength == inMem.lengths[0] && fvalues[1].arrayLength == inMem.lengths[1]) {
            nat.writeFloatMatrix_w(clQueue, memObj, fvalues) 
        }
        else if (inMem.type == UINT && fvalues == null && ivalues.arrayLength == inMem.lengths[0] && ivalues[1].arrayLength == inMem.lengths[1]) {
            nat.writeIntMatrix_w(clQueue, memObj, ivalues) 
        }
        else {
            out.println("Err in LDC write matrix")
            out.println("lens later: $(ivalues[0].arrayLength), $(ivalues[1].arrayLength)")
        }
    }

    Matrix LogicalComputeDevice:readMatrix(char name[]) {
        Matrix m = new Matrix()

        OpenMemArea inMem = openMemoryAreas.get(name)
        ChandleWrapper hand = inMem.hand
        int memObj = hand.handle

        String device = inMem.device

        ComputeQueue q = readQueues.get(device.string)
        int clQueue = q.queue_cl

        if (inMem.type == FLOAT) {
            dec buf[][] = new dec[inMem.lengths[0]][inMem.lengths[1]]
            buf = nat.readFloatMatrix_w(clQueue, memObj, buf)
            m.fvalues = buf
            m.ivalues = null
            return m
        }
        else {
            int buf[][] = new int[inMem.lengths[0]][inMem.lengths[1]]
            buf = nat.readIntMatrix_w(clQueue, memObj, buf)
            m.ivalues = buf
            m.fvalues = null
            return m
        }
    }

    void LogicalComputeDevice:destroyArray(char name[]) {
        OpenMemArea inMem = openMemoryAreas.get(name)
        ChandleWrapper handle = inMem.hand
        if(handle != null) {
            nat.destroyMemoryArea_w(handle.handle)
        }
        openMemoryAreas.delete(name)
        return
    }

    void LogicalComputeDevice:destroyMatrix(char name[]) {
        OpenMemArea inMem = openMemoryAreas.get(name)
        ChandleWrapper handle = inMem.hand
        if(handle != null) {
            nat.destroyMemoryArea_w(handle.handle)
        }
        openMemoryAreas.delete(name)
        return
    }

    char[] stripSource(char source[]) {
        //go char by char, if '\n' then rm
        // if '//' then rm all till next '\n'
        // if '/*' then rm all till next '*/'
        char stripped[] = new char[source.arrayLength]
        char lastChar = "A"
        char cur
        bool inBlockComment = false
        bool inComment = false
        bool isNewLine = false
        bool atStartOfComment = false

        int stripIndex = 0
        for (int i = 0; i < source.arrayLength; i++) {
            cur = source[i]

            if (cur == "\n") {
                isNewLine = true
                inComment = false
            }
            if (cur == "/" && lastChar == "/") {
                inComment = true
                atStartOfComment = true
            }
            if (cur == "*" && lastChar == "/") {
                inBlockComment = true
                atStartOfComment = true
            }
            if (cur == "/" && lastChar == "*") {
                inBlockComment = false
                atStartOfComment = true
            }

            if (!(inBlockComment || inComment || isNewLine)) {
                stripped[stripIndex] = source[i]
                stripIndex++
            }

            if (atStartOfComment) {
                stripIndex -= 1
            }

            isNewLine =  false
            atStartOfComment = false

            lastChar = cur
        }

        return stripped
    }

    void LogicalComputeDevice:loadProgram(char path[], char name[]) {
        TextFile source = new TextFile(path, File.READ)
        int sizeInBytes = source.getSize()
        char rawSource[]
        while (!source.eof()) {
            rawSource = new char[](rawSource, source.readLine())
            rawSource = new char[](rawSource, "\n")
        }

        int handles[] = nat.createProgram_w(rawSource)
        ChandleWrapper handlesWrapped[] = new ChandleWrapper[handles.arrayLength]
        for (int i = 0; i < handles.arrayLength; i++) {
            ChandleWrapper hand = new ChandleWrapper(handles[i])
            handlesWrapped[i] = hand
            ChandleWrapperArray arr = new ChandleWrapperArray()
            arr.array = handlesWrapped
            programs.put(name, arr) 
        }
        
    }

    String[] LogicalComputeDevice:getPrograms() {
        return null
    }

    bool isConst(char param[]) {
        String exploded[] = su.explode(param, ":")
        if (exploded[0].string == "const") {
            return true
        }
        else {
            return false
        }
    }

    bool isFloat(char param[]) {
        String exploded[] = su.explode(param, ":")
        if (su.ifind(exploded[1].string, ".") == StringUtil.NOT_FOUND) {
            return false
        }
        else {
            return true
        }
    }

    dec getDecConst(char param[]) {
        String exploded[] = su.explode(param, ":")
        out.println(exploded[1].string)
        return du.decFromString(exploded[1].string)
    }

    int getIntConst(char param[]) {
        String exploded[] = su.explode(param, ":")
        return iu.intFromString(exploded[1].string)
    }

    void LogicalComputeDevice:runProgram(char program[], String params[]) {
        ChandleWrapperArray arr = programs.get(program)
        ChandleWrapper progHandles[] = arr.array

        HashTable paramMap = new HashTable()
        
        int paramHandles[] = new int[params.arrayLength]
        int outputDims[]
        for (int i = 0; i < params.arrayLength; i++) {
            if (isConst(params[i].string)) {
                if (isFloat(params[i].string)) {
                    createArray(params[i].string, FLOAT, 1)
                    dec vals[] = new dec[1]
                    vals[0] = getDecConst(params[i].string)
                    writeArray(params[i].string, vals, null)          
                }
                else {
                    createArray(params[i].string, UINT, 1)
                    int vals[] = new int[1]
                    vals[0] = getIntConst(params[i].string)
                    writeArray(params[i].string, null, vals)          
                }
            }
            OpenMemArea x = openMemoryAreas.get(params[i].string)
            out.println(params[i].string)
            ChandleWrapper memHandle = x.hand
            paramHandles[i] = memHandle.handle
            String device = x.device
            paramMap.put(params[i].string, device)

            if (i == (params.arrayLength-1)) {
                outputDims = x.lengths
            }
        }

        int paramCount = paramHandles.arrayLength
        ChandleWrapper kernelHandles[] = new ChandleWrapper[progHandles.arrayLength]
        int rawKerHandles[] = new int[progHandles.arrayLength]
        bool kerPrepSuccess[] = new bool[progHandles.arrayLength]
        for (int k = 0; k < progHandles.arrayLength; k++) {
            int clProghandle = progHandles[k].handle
            rawKerHandles[k] = nat.prepareKernel_w(clProghandle, paramHandles, paramCount, program)
            kernelHandles[k] = new ChandleWrapper(rawKerHandles[k])
        }
        ChandleWrapperArray kerArr = new ChandleWrapperArray(kernelHandles)

        //hand kernels over to distManager with a map describing which params are on which devices
        distManager.execProgram(kerArr, paramMap, outputDims)

        return
    }
}
