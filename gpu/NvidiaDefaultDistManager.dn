component provides gpu.ComputeDistributionManager requires gpu.ComputeStats,
                                                            gpu.Compute,
                                                            data.adt.List,
                                                            data.adt.HashTable,
                                                            data.adt.Queue,
                                                            data.StringUtil su
                                                            {

    ComputeStats hardwareInfo
    Compute nat

    List asynchQueues
    List synchQueues

    String physicalDevices[]
    HashTable physicalDevicesIDs

    ComputeDistributionManager:ComputeDistributionManager(store ComputeStats physicalCompute, store Compute nativeCompute) {
        hardwareInfo = physicalCompute
        nat = nativeCompute

        asynchQueues = new List()
        synchQueues = new List()

        physicalDevices = hardwareInfo.getComputeDevices()
        int deviceIDs[] = hardwareInfo.getComputeDeviceIDs()

        //Search for device names starting with 'Intel'
        bool hits[] = new bool[physicalDevices.arrayLength]
        int hitCount = 0
        for (int i = 0; i < physicalDevices.arrayLength; i++) {
            hits[i] = su.startsWith(physicalDevices[i].string, "NVIDIA")
            hitCount+=hits[i]
        }

        //only retain device IDs and Names of Intel devices
        int deviceIDsKeep[] = new int[hitCount]
        String physicalDevicesKeep[] = new String[hitCount]
        int k = 0
        for (int i = 0; i < hitCount; i++) {
            bool next = false
            while (next == false) {
                next = hits[k]
                k++
            }
            deviceIDsKeep[i] = deviceIDs[k-1]
            physicalDevicesKeep[i] = physicalDevices[k-1]
        }

        deviceIDs = deviceIDsKeep
        physicalDevices = physicalDevicesKeep

        //map device names and device IDs
        physicalDevicesIDs = new HashTable()
        for (int i = 0; i < deviceIDs.arrayLength; i++) {
            ChandleWrapper hand = new ChandleWrapper(deviceIDs[i])
            physicalDevicesIDs.put(physicalDevices[i].string, hand) 
            ChandleWrapper e = physicalDevicesIDs.get(physicalDevices[i].string)
            int x = e.handle
        }

        //tell native library we want to use these devices
        nat.createContext_w(deviceIDs)

        //create one queue per physicalDevice
        for (int i = 0; i < deviceIDs.arrayLength; i++) {
            int queue_cl = nat.createSynchQueue_w(deviceIDs[i])
            ComputeQueue newQ = new ComputeQueue(queue_cl, new Queue(), physicalDevices[i], deviceIDs[i])
            synchQueues.add(newQ)
        }
    }

    //return all devices managed by this object so that the caller can create read/write queues for them
    HashTableItem[] ComputeDistributionManager:getReadWriteQueues(store HashTable rw[]) {
        HashTableItem devicesMap[] = physicalDevicesIDs.getContents()
        return devicesMap
    }

    //return the first device always
    HashTableItem ComputeDistributionManager:mallocWhichDevice() {
        HashTableItem keyValue = new HashTableItem()
        keyValue.key = physicalDevices[0].string
        keyValue.value = physicalDevicesIDs.get(physicalDevices[0].string)
        return keyValue
    }

    //given a device get its synchronous command queue
    ComputeQueue getQueueByDevice(int device) {
        for (int i = 0; i < synchQueues.getLength(); i++) {
            ComputeQueue q = synchQueues.getIndex(i)
            if (q.physicalDeviceID == device) {
                return q
            }
        }
        return null
    }

    void ComputeDistributionManager:execProgram(ChandleWrapperArray kernelHandles, HashTable memoryObjects, int outputDims[]) {
        //the memoryObjects to be used as parameters for this kernel
        HashTableItem memObjs[] = memoryObjects.getContents()

        //the prepared kernel handles
        ChandleWrapper kernelHandlesArr[] = kernelHandles.array
        int rawKerHandles[] = new int[kernelHandlesArr.arrayLength]

        //some kernel handles may be null which indicated the underlying API failed to build them
        //this is usually because one or more of the parameters are stored on a device different to the device
        //the kernel is built for
        bool kerPrepSuccess[] = new bool[kernelHandlesArr.arrayLength]

        //check which kernel handles have non null values
        //mark the corrisponding cell in kerPrepSuccess as true
        for (int i = 0; i < rawKerHandles.arrayLength; i++) {
            rawKerHandles[i] = kernelHandlesArr[i].handle
            if (rawKerHandles[i] != 0) {
                kerPrepSuccess[i] = true
            }
            else {
                kerPrepSuccess[i] = false
            }
        }

        int succCount = 0 
        int kerIndex = 0
        int kerToExec = 0
        //count how many kernels were built successfully
        // and mark the the index of the most recently succesful kernel in kerIndex
        for (int k = 0; k < kerPrepSuccess.arrayLength; k++) {
            if (kerPrepSuccess[k]) {
                succCount += 1
                kerIndex = k
            }
        }

        //if there was only one successfully built kernel execute that one
        //its handle will be in the rawKerHandles array and its index will be
        // stored in kerIndex
        if (succCount == 1) {
            kerToExec = rawKerHandles[kerIndex]
            String device = memObjs[0].value
            ChandleWrapper devIdWrap = physicalDevicesIDs.get(device.string)
            int dev = devIdWrap.handle
            ComputeQueue q = getQueueByDevice(dev)
            nat.runKernel_w(kerToExec, q.queue_cl, outputDims)
        }

        // if no kernels where succesful report a fatal error
        // though other implimentation on ComputeDistributionManager can handle this
        // you would have to copy the parameter contents onto one device and attempt to
        // rebuild the kernel
        else if (succCount == 0) {
            throw new Exception("All kernels failed to build, cannot execute program.")
        }
        // if more than one kernel was built succesfully
        // execute the kernel in the rawKerHandles array at
        // the index pointed to by kerIndex
        else { //succCount > 1
            kerToExec = rawKerHandles[kerIndex]
            String device = memObjs[0].value
            ChandleWrapper devIdWrap = physicalDevicesIDs.get(device.string)
            int dev = devIdWrap.handle
            ComputeQueue q = getQueueByDevice(dev)
            nat.runKernel_w(kerToExec, q.queue_cl, outputDims)
        }
    }

}
