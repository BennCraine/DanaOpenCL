interface OpenCLLib {
    void init()
	void findPlatforms()
    int[] getComputeDeviceIDs()
    String[] getComputeDevices()
    int createContext()
    int createAsynchQueue(int context)
    int createSynchQueue(int context)
    int createArray(int context, int byteSize)
    int createMatrix(int context, int byteSize)
    void destroyMemoryArea(int memObj_cl)
    int createProgram(int context, char source[])
    void writeIntArray(int queue_cl, int memObj_cl, int values[])
    int[] readIntArray(int queue_cl, int memObj_cl, int buf[])
    int prepareKernel(int clProghandle, int paramHandles[], int paramCount, char program[])
    void runKernel(int clKernel, int queue_cl)
}

data ChandleWrapper {
    int handle
}

component provides gpu.ComputeManager, gpu.LogicalComputeDevice requires 
                                                                native OpenCLLib lib, 
                                                                io.Output out, 
                                                                io.TextFile,
                                                                data.adt.Queue, 
                                                                data.adt.List, 
                                                                data.adt.HashTable, 
                                                                data.IntUtil iu {

    implementation ComputeManager {

        ComputeManager:ComputeManager() {
            lib.init()
        }

        void ComputeManager:findPlatforms() {
            lib.findPlatforms()
        }

        String[] ComputeManager:getComputeDevices() {
            String devices[] = lib.getComputeDevices()
            return devices
        }

        int[] ComputeManager:getComputeDeviceIDs() {
            int ids[] = lib.getComputeDeviceIDs()
            return ids
        }
    }

    implementation LogicalComputeDevice {
        int context_cl

        String physicalDevices[]
        HashTable physicalDevicesIDs

        List asynchQueues
        List synchQueues

        HashTable readQueues
        HashTable writeQueues

        HashTable openMemoryAreas
        
        HashTable programs

        LogicalComputeDevice:LogicalComputeDevice(ComputeManager physicalCompute) {
            asynchQueues = new List()
            synchQueues = new List()

            readQueues = new HashTable()
            writeQueues = new HashTable()

            openMemoryAreas = new HashTable()
            physicalDevicesIDs = new HashTable()

            programs = new HashTable()

            physicalDevices = physicalCompute.getComputeDevices()
            int deviceIDs[] = physicalCompute.getComputeDeviceIDs()

            for (int i = 0; i < deviceIDs.arrayLength; i++) {
                out.println("$(iu.makeString(deviceIDs[i]))")
                ChandleWrapper hand = new ChandleWrapper(deviceIDs[i])
                physicalDevicesIDs.put(physicalDevices[i].string, hand) 
                ChandleWrapper e = physicalDevicesIDs.get(physicalDevices[i].string)
                int x = e.handle
                out.println("$(iu.makeString(x))")
                out.println("--------------------------------")
            }

            //create context in native
            context_cl = lib.createContext()

            //create queue in native
            int queue_cl = lib.createSynchQueue(context_cl)
            ComputeQueue firstQueue = new ComputeQueue(queue_cl, new Queue(), physicalDevices[0])
            synchQueues.add(firstQueue)

            //create read queues, one for each physicalDevice
            queue_cl = lib.createSynchQueue(context_cl)
            ComputeQueue readQueue = new ComputeQueue(queue_cl, new Queue(), physicalDevices[0])
            readQueues.put(physicalDevices[0].string, readQueue)

            //create write queues, one for each physicalDevice
            queue_cl = lib.createSynchQueue(context_cl)
            ComputeQueue writeQueue = new ComputeQueue(queue_cl, new Queue(), physicalDevices[0])
            writeQueues.put(physicalDevices[0].string, writeQueue)
        }

        void LogicalComputeDevice:setPhysicalDevice(String devices[]) {
            return 
        }

        void LogicalComputeDevice:addComputeQueue(bool isSynch, String physicalDevice) {
            if(isSynch) {
                int queue_cl = lib.createSynchQueue(context_cl)
                ComputeQueue firstQueue = new ComputeQueue(queue_cl, new Queue(), physicalDevices[0])
                synchQueues.add(firstQueue)
            }
            else {
                int queue_cl = lib.createAsynchQueue(context_cl)
                ComputeQueue firstQueue = new ComputeQueue(queue_cl, new Queue(), physicalDevices[0])
                asynchQueues.add(firstQueue)
            }
            return 
        }

        Queue[] LogicalComputeDevice:getComputeQueues() {
            //TODO add asynch queues
            Queue returnVal[] = new Queue[synchQueues.getLength()]
            for (int i = 0; i < synchQueues.getLength(); i++) {
                ComputeQueue cq = synchQueues.getIndex(i)
                returnVal[i] = cq.q
            }
            return returnVal
        }

        void execCommand(ComputeCommand cmd, ComputeQueue cq) {
            if (cmd.commandCode == RUN_KERNEL) {
                ChandleWrapper hand = cmd.params.getIndex(0)
                int kerHandle = hand.handle
                int queueHandle = cq.queue_cl
                out.println("running ker")
                lib.runKernel(kerHandle, queueHandle)
            }
        }

        void LogicalComputeDevice:execQueue(Queue q) {
            //find queue

            //call native lib to exec command


            ComputeQueue cq = synchQueues.getIndex(0)
            ComputeCommand cmd = cq.q.service()
            execCommand(cmd, cq)
            return
        }

        void LogicalComputeDevice:enqueueCommand(store ComputeCommand command, opt ComputeQueue queue) {
            //TODO add support for multqueues
            ComputeQueue q = synchQueues.getIndex(0)
            ComputeCommand cloneCmd = clone command
            q.q.add(cloneCmd)
            return
        }

        void LogicalComputeDevice:createArray(char name[], int types, int length) {
            //TODO: multiply length by type size in bytes
            int clMemObj = lib.createArray(context_cl, length*8)
            ChandleWrapper handle = new ChandleWrapper(clMemObj)
            openMemoryAreas.put(name, handle)
            return 
        }

        void LogicalComputeDevice:createMatrix(char name[], int type, int dim, int lengths[]) {
            return 
        }

        void LogicalComputeDevice:writeArray(char name[], dec fvalues[], int ivalues[]) {
            //get memObj from HashTable
            ChandleWrapper hand = openMemoryAreas.get(name)
            int clMemObj = hand.handle

            //check values.len = memObj.len

            ComputeQueue q = writeQueues.get(physicalDevices[0].string)
            int clQueue = q.queue_cl

            lib.writeIntArray(clQueue, clMemObj, ivalues) 
        }

        int[] LogicalComputeDevice:readArray(char name[]) {
            ChandleWrapper hand = openMemoryAreas.get(name)
            int clMemObj = hand.handle

            ComputeQueue q = readQueues.get(physicalDevices[0].string)
            int clQueue = q.queue_cl

            int buf[] = new int[10]

            buf = lib.readIntArray(clQueue, clMemObj, buf)

            return buf
        }

        void LogicalComputeDevice:destroyArray(char name[]) {
            ChandleWrapper handle = openMemoryAreas.get(name)
            if(handle != null) {
                lib.destroyMemoryArea(handle.handle)
            }
            openMemoryAreas.delete(name)
            return
        }

        void LogicalComputeDevice:destroyMatrix(char name[]) {
            return
        }

        void LogicalComputeDevice:loadProgram(char path[], char name[]) {
            //TODO: remove comments and all \n chars
            //TODO: build for all devices in this context
            TextFile source = new TextFile(path, File.READ)
            int sizeInBytes = source.getSize()
            char rawSource[]
            while (!source.eof()) {
                rawSource = new char[](rawSource, source.readLine())
            }
            out.println(rawSource)

            int handle = lib.createProgram(context_cl, rawSource)
            ChandleWrapper hand = new ChandleWrapper(handle)
            programs.put(name, hand)
            
        }

        String[] LogicalComputeDevice:getPrograms() {
            return null
        }

        ComputeCommand LogicalComputeDevice:prepareKernel(char program[], String params[], store List l) {
            ChandleWrapper hand = programs.get(program)
            int clProghandle = hand.handle

            int paramHandles[] = new int[params.arrayLength]
            for (int i = 0; i < params.arrayLength; i++) {
                ChandleWrapper x = openMemoryAreas.get(params[i].string)
                paramHandles[i] = x.handle
            }

            int paramCount = params.arrayLength
            
            int kernelHandle = lib.prepareKernel(clProghandle, paramHandles, paramCount, program)
            ChandleWrapper kerHand = new ChandleWrapper(kernelHandle)

            ComputeCommand cmd = new ComputeCommand(RUN_KERNEL, l)
            l.add(kerHand)
            
            return cmd
        }
    }
    
}
