uses data.String

interface OpenCLLib {
    int init()
	void findPlatforms()
    int[] getComputeDeviceIDs()
    String[] getComputeDevices()
    void createContext(int devices[], int danaComp)
    int createAsynchQueue(int device, int danaComp)
    int createSynchQueue(int device, int danaComp)
    int createArray(int device, int length, int type, int danaComp)
    int createMatrix(int device, int width, int height, int type, int danaComp)
    void destroyMemoryArea(int memObj_cl)
    int[] createProgram(char source[], int danaComp)
    void writeIntArray(int queue_cl, int memObj_cl, int values[])
    int[] readIntArray(int queue_cl, int memObj_cl, int buf[])
    void writeFloatArray(int queue_cl, int memObj_cl, dec values[])
    dec[] readFloatArray(int queue_cl, int memObj_cl, int len)
    void writeIntMatrix(int queue_cl, int memObj_cl, int buf[][])
    int[][] readIntMatrix(int queue_cl, int memObj_cl, int buf[][])
    void writeFloatMatrix(int queue_cl, int memObj_cl, dec buf[][])
    dec[][] readFloatMatrix(int queue_cl, int memObj_cl, dec buf[][])
    int prepareKernel(int clProghandle, int paramHandles[], int paramCount, char program[])
    void runKernel(int clKernel, int queue_cl, int outputDims[])
}

const int FLOAT = 0
const int UINT = 1

component provides ComputeInfo, Compute(Destructor), Program(Destructor), ArrayInt(Destructor), ArrayDec(Destructor), MatrixInt(Destructor), MatrixDec(Destructor) requires native OpenCLLib lib, io.Output out {

    implementation ComputeInfo {

        /* {"@description" : "Returns all the devices (by name) available to the system"} */
        String[] ComputeInfo:getDevices()
            {
            return lib.getComputeDevices()
            }
    }
    
    implementation Compute {
        int handle
        char device[]
        int deviceID
        int queueHandle

        /* {"@description" : "Initlises whatever API is being used in the native library to communicated with the compute devices"} */
        Compute:Compute(char dev[])
            {
            handle = lib.init()

            device = dev

            int deviceIDs[] = lib.getComputeDeviceIDs()
            String devices[] = lib.getComputeDevices()

            for (int i = 0; i < devices.arrayLength; i++)
                {
                if (devices[i].string == device)
                    {
                    deviceID = deviceIDs[i]
                    break
                    }
                }
            
            lib.createContext(deviceID, handle)

            queueHandle = lib.createSynchQueue(deviceID, handle)
            }
        
        char[] Compute:getDevice()
            {
            return device
            }

        /* {"@description" : "Asks the native library to execute the kernel given by 'clKernel' through the queue given by 'queue_cl' and execute it on a set of threads with dimention and size outputDims[0] * outputDims[0+i] * ..., * outputDims[n]"} */
        void Compute:runProgram(Program p, int outputDims[])
            {
            int khandle = lib.prepareKernel(p.phandle, p.paramHandles, p.paramHandles.arrayLength, p.functionName)
            lib.runKernel(khandle, queueHandle, outputDims)
            }
        
        void Destructor:destroy()
            {
            //destroy context?
            //destroy queue?
            }
    }

    implementation Program {
        int phandle
        char program[]
        char functionName[]
        int paramHandles[]
        
        Program:Program(store Compute device, char fName[], char source[])
            {
            int res[] = lib.createProgram(source, device.handle)
            phandle = res[0]
            program = source
            functionName = fName
            }

        void Program:setParameters(ExtMemory parameters[])
            {
            paramHandles = new int[parameters.arrayLength]
            for (int i = 0; i < paramHandles.arrayLength; i++)
                {
                paramHandles[i] = parameters[i].getMemoryLoc()
                }
            }
        
        void Destructor:destroy()
            {
            //destroy phandle?
            }
    }

    implementation ArrayInt {
        int handle
        Compute dev
        int len

        ArrayInt:ArrayInt(store Compute device, int length)
            {
            handle = lib.createArray(device.deviceID, length, UINT, device.handle)
            len = length
            dev = device
            }

        void ArrayInt:write(int content[])
            {
            lib.writeIntArray(dev.queueHandle, handle, content)
            }

        int[] ArrayInt:read()
            {
            return lib.readIntArray(dev.queueHandle, handle, len) //buf??
            }
        
        int ArrayInt:getMemoryLoc()
            {
            return handle
            }
        
        void Destructor:destroy()
            {
            lib.destroyMemoryArea(handle)
            }
    }

    implementation ArrayDec {
        int handle
        Compute dev
        int len

        ArrayDec:ArrayDec(store Compute device, int length)
            {
            handle = lib.createArray(device.deviceID, length, FLOAT, device.handle)
            dev = device
            len = length
            }

        void ArrayDec:write(dec content[])
            {
            lib.writeFloatArray(dev.queueHandle, handle, content)
            }

        dec[] ArrayDec:read()
            {
            return lib.readFloatArray(dev.queueHandle, handle, len)
            }
        
        int ArrayDec:getMemoryLoc()
            {
            return handle
            }
        
        void Destructor:destroy()
            {
            lib.destroyMemoryArea(handle)
            }
    }

    implementation MatrixInt {
        int handle
        Compute dev
        int w
        int h

        MatrixInt:MatrixInt(store Compute device, int width, int height)
            {
            handle = lib.createMatrix(device.deviceID, width, height, UINT, device.handle)
            dev = device
            w = width
            h = height
            }

        void MatrixInt:write(int content[][])
            {
            lib.writeIntMatrix(dev.queueHandle, handle, content)
            }

        int[][] MatrixInt:read()
            {
            return lib.readIntMatrix(dev.queueHandle, handle, null)
            }
        
        int MatrixInt:getMemoryLoc()
            {
            return handle
            }
        
        void Destructor:destroy()
            {
            lib.destroyMemoryArea(handle)
            }
    }

    implementation MatrixDec {
        int handle
        Compute dev
        int w
        int h

        MatrixDec:MatrixDec(store Compute device, int width, int height)
            {
            handle = lib.createMatrix(device.deviceID, width, height, FLOAT, device.handle)
            dev = device
            w = width
            h = height
            }

        void MatrixDec:write(dec content[][])
            {
            lib.writeFloatMatrix(dev.queueHandle, handle, content)
            }

        dec[][] MatrixDec:read()
            {
            return lib.readFloatMatrix(dev.queueHandle, handle, null)
            }
        
        int MatrixDec:getMemoryLoc()
            {
            return handle
            }
        
        void Destructor:destroy()
            {
            lib.destroyMemoryArea(handle)
            }
    }
}
