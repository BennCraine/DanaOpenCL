uses data.String

interface OpenCLLib {
    int init()
	void findPlatforms()
    int[] getComputeDeviceIDs()
    String[] getComputeDevices()
    void createContext(int devices[], int danaComp)
    int createAsynchQueue(int device, int danaComp)
    int createSynchQueue(int device, int danaComp)
    int createArray(int device, int length, int type, int danaComp)
    int createMatrix(int device, int width, int height, int type, int danaComp)
    void destroyMemoryArea(int memObj_cl)
    int[] createProgram(char source[], int danaComp)
    void writeIntArray(int queue_cl, int memObj_cl, int values[])
    int[] readIntArray(int queue_cl, int memObj_cl, int buf[])
    void writeFloatArray(int queue_cl, int memObj_cl, dec values[])
    dec[] readFloatArray(int queue_cl, int memObj_cl, int len)
    void writeIntMatrix(int queue_cl, int memObj_cl, int buf[][])
    int[][] readIntMatrix(int queue_cl, int memObj_cl, int buf[][])
    void writeFloatMatrix(int queue_cl, int memObj_cl, dec buf[][])
    dec[][] readFloatMatrix(int queue_cl, int memObj_cl, dec buf[][])
    int prepareKernel(int clProghandle, int paramHandles[], int paramCount, char program[])
    void runKernel(int clKernel, int queue_cl, int outputDims[])
}

component provides gpu.Compute requires native OpenCLLib lib, 
                                        io.Output out, 
                                        io.TextFile,
                                        data.adt.Queue, 
                                        data.adt.List, 
                                        data.adt.HashTable, 
                                        data.IntUtil iu {

    int myDanaComp

    void Compute:init_w() {
        myDanaComp = lib.init()
    }
	void Compute:findPlatforms_w() {
        lib.findPlatforms()
    }
    int[] Compute:getComputeDeviceIDs_w() {
        return lib.getComputeDeviceIDs()
    }
    String[] Compute:getComputeDevices_w() {
        return lib.getComputeDevices()
    }
    void Compute:createContext_w(int devices[]) {
        lib.createContext(devices, myDanaComp)
    }
    int Compute:createAsynchQueue_w(int device) {
        return lib.createAsynchQueue(device, myDanaComp)
    }
    int Compute:createSynchQueue_w(int device) {
        return lib.createSynchQueue(device, myDanaComp)
    }
    int Compute:createArray_w(int device, int length, int type) {
        if (type == FLOAT) {
            int arr = lib.createArray(device, length, FLOAT, myDanaComp)
            return arr
        }
        else if (type == UINT) {
            int arr = lib.createArray(device, length, UINT, myDanaComp)
            return arr
        }
        else {
            return 0
        }
    }
    int Compute:createMatrix_w(int device, int width, int height, int type) {
        if (type == FLOAT) {
            int mat = lib.createMatrix(device, width, height, FLOAT, myDanaComp)
            return mat
        }
        else if (type == UINT) {
            int mat = lib.createMatrix(device, width, height, UINT, myDanaComp)
            return mat
        }
        else {
            return 0
        }
    }
    void Compute:destroyMemoryArea_w(int memObj_cl) {
        lib.destroyMemoryArea(memObj_cl)
    }
    int[] Compute:createProgram_w(char source[]) {
        int x[] = lib.createProgram(source, myDanaComp)
        return x
    }
    void Compute:writeIntArray_w(int queue_cl, int memObj_cl, int values[]) {
        lib.writeIntArray(queue_cl, memObj_cl, values)
    }
    int[] Compute:readIntArray_w(int queue_cl, int memObj_cl, int buf[]) {
        return lib.readIntArray(queue_cl, memObj_cl, buf)
    }
    void Compute:writeFloatArray_w(int queue_cl, int memObj_cl, dec values[]) {
        lib.writeFloatArray(queue_cl, memObj_cl, values)
    }
    dec[] Compute:readFloatArray_w(int queue_cl, int memObj_cl, int len) {
        return lib.readFloatArray(queue_cl, memObj_cl, len)
    }
    void Compute:writeIntMatrix_w(int queue_cl, int memObj_cl, int buf[][]) {
        lib.writeIntMatrix(queue_cl, memObj_cl, buf)
    }
    int[][] Compute:readIntMatrix_w(int queue_cl, int memObj_cl, int buf[][]) {
        return lib.readIntMatrix(queue_cl, memObj_cl, buf)
    }
    void Compute:writeFloatMatrix_w(int queue_cl, int memObj_cl, dec buf[][]) {
        lib.writeFloatMatrix(queue_cl, memObj_cl, buf)
    }
    dec[][] Compute:readFloatMatrix_w(int queue_cl, int memObj_cl, dec buf[][]) {
        return lib.readFloatMatrix(queue_cl, memObj_cl, buf)
    }
    int Compute:prepareKernel_w(int clProghandle, int paramHandles[], int paramCount, char program[]) {
        return lib.prepareKernel(clProghandle, paramHandles, paramCount, program)
    }
    void Compute:runKernel_w(int clKernel, int queue_cl, int outputDims[]) {
        lib.runKernel(clKernel, queue_cl, outputDims)
    }
}
