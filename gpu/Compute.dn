const int FLOAT = 0
const int UINT = 1

uses data.String
interface OpenCLLib {
    void init()
	void findPlatforms()
    int[] getComputeDeviceIDs()
    String[] getComputeDevices()
    void createContext(int devices[])
    int createAsynchQueue(int device)
    int createSynchQueue(int device)
    int createArray(int device, int byteSize)
    int createMatrix(int device, int width, int height)
    void destroyMemoryArea(int memObj_cl)
    int createProgram(char source[])
    void writeIntArray(int queue_cl, int memObj_cl, int values[])
    int[] readIntArray(int queue_cl, int memObj_cl, int buf[])
    void writeIntMatrix(int queue_cl, int memObj_cl, int buf[][])
    int[][] readIntMatrix(int queue_cl, int memObj_cl, int buf[][])
    int prepareKernel(int clProghandle, int paramHandles[], int paramCount, char program[])
    void runKernel(int clKernel, int queue_cl)
}

component provides gpu.Compute requires native OpenCLLib lib, 
                                        io.Output out, 
                                        io.TextFile,
                                        data.adt.Queue, 
                                        data.adt.List, 
                                        data.adt.HashTable, 
                                        data.IntUtil iu {

    void Compute:init_w() {
        lib.init()
    }
	void Compute:findPlatforms_w() {
        lib.findPlatforms()
    }
    int[] Compute:getComputeDeviceIDs_w() {
        return lib.getComputeDeviceIDs()
    }
    String[] Compute:getComputeDevices_w() {
        return lib.getComputeDevices()
    }
    void Compute:createContext_w(int devices[]) {
        lib.createContext(devices)
    }
    int Compute:createAsynchQueue_w(int device) {
        return lib.createAsynchQueue(device)
    }
    int Compute:createSynchQueue_w(int device) {
        return lib.createSynchQueue(device)
    }
    int Compute:createArray_w(int device, int byteSize) {
        return lib.createArray(device, byteSize)
    }
    int Compute:createMatrix_w(int device, int width, int height) {
        return lib.createMatrix(device, width, height)
    }
    void Compute:destroyMemoryArea_w(int memObj_cl) {
        lib.destroyMemoryArea(memObj_cl)
    }
    int Compute:createProgram_w(char source[]) {
        return lib.createProgram(source)
    }
    void Compute:writeIntArray_w(int queue_cl, int memObj_cl, int values[]) {
        lib.writeIntArray(queue_cl, memObj_cl, values)
    }
    int[] Compute:readIntArray_w(int queue_cl, int memObj_cl, int buf[]) {
        return lib.readIntArray(queue_cl, memObj_cl, buf)
    }
    void Compute:writeIntMatrix_w(int queue_cl, int memObj_cl, int buf[][]) {
        lib.writeIntMatrix(queue_cl, memObj_cl, buf)
    }
    int[][] Compute:readIntMatrix_w(int queue_cl, int memObj_cl, int buf[][]) {
        return lib.readIntMatrix(queue_cl, memObj_cl, buf)
    }
    int Compute:prepareKernel_w(int clProghandle, int paramHandles[], int paramCount, char program[]) {
        return lib.prepareKernel(clProghandle, paramHandles, paramCount, program)
    }
    void Compute:runKernel_w(int clKernel, int queue_cl) {
        lib.runKernel(clKernel, queue_cl)
    }
}
